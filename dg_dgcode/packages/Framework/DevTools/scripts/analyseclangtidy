#!/usr/bin/env python3
import pathlib
import sys
import os
import io
import shlex
import shutil
import subprocess
import argparse
try:
    import yaml
except ImportError:
    raise SystemExit("Could not import yaml module, try: python3 -mpip install pyyaml")
try:
    import readline
except ImportError:
    print("WARNING: Could not import readline module - command line will be less nice")

def decodeOffset(filepath,offset):
    #not sure if this is correct for a non single-byte encoding...
    data=filepath.read_bytes()[0:offset]
    l=data.splitlines()
    return len(l),len(l[-1])

#def guess_orig_file(filename):
#    l=list((pathlib.Path(os.environ['DGCODE_DIR'])/'packages/Projects/NCrystal').glob('dist*/**/%s'%filename))
#    return l

class Diagnostics:

    @staticmethod
    def _decode_entry(d):
        msg=d['Message']
        fileoffset=d['FileOffset']
        filepath=pathlib.Path(d['FilePath'])
        lineno,colno = decodeOffset(filepath,int(fileoffset))
        return dict(filepath=filepath,msg=msg,lineno=lineno,colno=colno)

    def get_subentry_info(self,subentry):
        return self.get_multiline_info( subentry = subentry )

    def launch_editor(self,subentry=None,path_rewrite_glob_pattern=None):
        if subentry is None:
            e=self._entry
        else:
            e=self._notes[subentry]
        fp=e['filepath']
        if path_rewrite_glob_pattern:
            guess_orig=list((pathlib.Path(os.environ['DGCODE_DIR'])/'packages').glob(path_rewrite_glob_pattern.replace(':FILENAME:',fp.name)))
            #guess_orig=guess_orig_file(fp.name)
            if len(guess_orig)!=1:
                print()
                print("WARNING: Could not guess original dgcode file from:",fp)
                print()
            else:
                fp=guess_orig[0]
                print()
                print("NB: Editing original dgcode file:",fp)
                print()

        subprocess.Popen([shutil.which('emacs'),
                          '+%i:%i'%(e['lineno'],e['colno']),
                          str(fp)])

    def n_sub_entries(self):
        return len(self._notes)

    def get_one_line_summary(self):
        return '%s %s : %s'%( self._category.split('.')[-1].ljust(30),
                              '%s [L%s]'%(self._entry['filepath'].name,self._entry['lineno']),
                              self._entry['msg'] )

    def get_multiline_info(self,subentry=None):
        #self._category = d['DiagnosticName']
        #self._notes = list(Diagnostics._decode_entry(e) for e in d['Notes'])
        #self._entry = Diagnostics._decode_entry(d['DiagnosticMessage'])
        l=[]
        if subentry is None:
            l.append('%s:'%self._category)
            l.append('  %s L%i/C%i'%(self._entry['filepath'],self._entry['lineno'],self._entry['colno']))
            l.append('  %s'%self._entry['msg'])
        for i,e in enumerate(self._notes):
            if subentry is not None and i!=subentry:
                continue
            l.append('')
            l.append(' -> step #%i'%i)
            l.append('   %s L%i/C%i'%(e['filepath'],e['lineno'],e['colno']))
            l.append('   %s'%e['msg'])
        return l

    def __init__(self,diagnostics_entry_as_dict):
        d=diagnostics_entry_as_dict
        self._category = d['DiagnosticName']
        self._notes = list(Diagnostics._decode_entry(e) for e in d['Notes'])
        self._entry = Diagnostics._decode_entry(d['DiagnosticMessage'])

    def __str__(self):
        return ' / '.join([self._category,self._entry['filepath'].name,self._entry['msg'],str(self._entry['lineno']),str(self._entry['colno'])])

def parse(logfile):
    logfile=pathlib.Path(logfile)
    assert logfile.exists()

    issues=[]
    issue = None
    for l in logfile.read_text().splitlines():
        if l=='Diagnostics:':
            assert issue is None
            issue = []
        if issue is not None:
            issue.append(l)
        if l=='...':
            assert issue is not None
            issues.append(issue)
            issue=None
    assert issue is None
    out=[]
    for issue in issues:
        ddict=yaml.safe_load(io.StringIO('\n'.join(issue)))
        dlist=ddict['Diagnostics']
        for d in dlist:
            out.append(Diagnostics(d))
    return out

def analyse(logfile,path_rewrite_glob_pattern):
    diagnostic_list = parse(logfile)
    def printall():
        for i,d in enumerate(diagnostic_list):
            print( '%s)'%(str(i).rjust(2)), d.get_one_line_summary() )
    printall()
    while True:
        print()
        print('Options: [l]ist, [q]uit, <digit>: show details, e<digit>: open editor on entry, e<digit>#<digit>: open editor on sub entry.')
        try:
            choice=input('  >> ').strip().lower()
        except (EOFError,KeyboardInterrupt):
            print("Aborted by user")
            sys.exit(0)
        c=choice.lower()
        if not c:
            continue
        if c in ('q','quit','break','exit'):
            break
        if c in ('l','list'):
            printall()
            continue
        if c.isdigit() and int(c)<len(diagnostic_list):
            d=diagnostic_list[int(c)]
            print('\n'.join(d.get_multiline_info()))
            continue
        if c.startswith('e') and c[1:].isdigit() and int(c[1:]) < len(diagnostic_list):
            d=diagnostic_list[int(c[1:])]
            print('\n'.join(d.get_multiline_info()))
            d.launch_editor(path_rewrite_glob_pattern=path_rewrite_glob_pattern)
            continue
        if c.startswith('e') and '#' in c:
            _=c[1:].split('#')
            if len(_)==2 and _[0].isdigit() and int(_[0])<len(diagnostic_list) and _[1].isdigit():
                a,b=int(_[0]),int(_[1])
                d=diagnostic_list[a]
                if b>=d.n_sub_entries():
                    continue
            print('\n'.join(d.get_subentry_info(b)))
            d.launch_editor(subentry=b,path_rewrite_glob_pattern=path_rewrite_glob_pattern)
            continue

        print('Error: Unknown option.')

def parse_cmdline():
    descr="""Parses clang-tidy output and presents it in very basic interactive fashion"""

    parser = argparse.ArgumentParser(description=descr)

    parser.add_argument('input_file', metavar='FILE', type=lambda x : pathlib.Path(x),
                        help="Logfile to parse.")

    parser.add_argument('--pathsearch', metavar='PATTERN', type=str, default='',
                        help='''glob expression which can be used to rewrite file paths (this is intended
                        when clang-tidy ran on exported code and we want to redirect to code inside dgcode.
                        Example PATTERN which looks for NCrystal src files is
                        "Projects/NCrystal/dist*/**/lib*/:FILENAME:".''')
    args=parser.parse_args()
    if not args.input_file.exists():
        parser.error('Non-existing input file: %s'%args.input_file)
    return args

def main():
    args = parse_cmdline()
    print(args.input_file)
    analyse(args.input_file,path_rewrite_glob_pattern=args.pathsearch)

if __name__=='__main__':
    main()
